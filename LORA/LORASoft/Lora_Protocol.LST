C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE LORA_PROTOCOL
OBJECT MODULE PLACED IN Lora_Protocol.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Lora_Protocol.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "Lora.h"
   2          unsigned char bSynWord;
   3          unsigned char DataSize = 0;
   4          unsigned char PaketSize;
   5          unsigned char Lora_Uart_State;
   6          unsigned char Check_Btye;
   7          unsigned char temp1;
   8          
   9          unsigned char bSynWord_MCU;
  10          unsigned char DataSize_MCU;
  11          unsigned char PaketSize_MCU;
  12          unsigned char Check_Btye_MCU;
  13          unsigned char MCU_Uart_State;
  14          unsigned char xdata TX_buf[128];
  15          unsigned char xdata TX_buf2[128];
  16          unsigned char xdata command[23];
  17          unsigned char info_num;   //查询信息条数
  18          
  19          
  20          typedef struct Oves_cmd
  21          {
  22              unsigned char PPID[13];
  23              unsigned char OPID[13];
  24          };
  25          
  26          
  27          unsigned char code crc_array[256] = {
  28             0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83,
  29             0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41, 
  30             0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e,
  31             0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc, 
  32             0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0,
  33             0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62, 
  34             0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d,
  35             0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff,
  36             0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5, 
  37             0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07,
  38             0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58,
  39             0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a,
  40             0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6, 
  41             0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24, 
  42             0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b,
  43             0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9, 
  44             0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f, 
  45             0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd,
  46             0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92,
  47             0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50, 
  48             0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c, 
  49             0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee, 
  50             0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1, 
  51             0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73, 
  52             0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49,
  53             0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b,
  54             0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4,
  55             0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16, 
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 2   

  56             0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a, 
  57             0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8, 
  58             0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7,
  59             0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35,
  60          };
  61          void MCU_Uart_Process(void)
  62          {
  63   1        if(bSynWord_MCU == 0)
  64   1        {
  65   2          buffer[0] = buffer[1];
  66   2          buffer[1] = buffer[2];
  67   2          buffer[2] = SBUF;
  68   2          if(buffer[0] == 0xc5 && buffer[1] == 0x6a && buffer[2] == 0x29)//Lora终端有数据传送过来
  69   2          {
  70   3            bSynWord_MCU = 1;
  71   3          }
  72   2        }
  73   1        else
  74   1        {
  75   2      
  76   2          buffer[DataSize_MCU+3] = SBUF;
  77   2          PaketSize_MCU = buffer[3];
  78   2          DataSize_MCU++;
  79   2          if(DataSize_MCU == PaketSize_MCU - 3)
  80   2          {
  81   3            bSynWord_MCU = 0;
  82   3            DataSize_MCU = 0;
  83   3            Check_Btye_MCU = CRC8(buffer,PaketSize_MCU - 1);
  84   3            if(buffer[PaketSize_MCU - 1] == Check_Btye_MCU)
  85   3            {
  86   4              MCU_Uart_State = 1;
  87   4              SYS_STATE = 0;           //系统收发正常
  88   4            }
  89   3          }
  90   2        }
  91   1      }
  92          void Lora_Uart_Process(void)
  93          {
  94   1        if(bSynWord == 0)
  95   1        { 
  96   2          buffer2[0] = buffer2[1];
  97   2          buffer2[1] = buffer2[2];
  98   2          buffer2[2] = S2BUF;
  99   2          if(buffer2[0] == 0xaf && buffer2[1] == 0x00 && buffer2[2] == 0x00)//Lora终端有数据传送过来
 100   2          {
 101   3            bSynWord = 1;
 102   3          }
 103   2        }
 104   1        else
 105   1        {
 106   2              buffer2[DataSize+3] = S2BUF;
 107   2              DataSize++;
 108   2              if(DataSize == 8)
 109   2              PaketSize = buffer2[10];
 110   2               if(DataSize == PaketSize +10)
 111   2               {
 112   3                bSynWord = 0;
 113   3                DataSize = 0; 
 114   3                Check_Btye = GetCheckSum_Xor(buffer2,PaketSize + 10);          
 115   3                if(buffer2[PaketSize+11] == Check_Btye)
 116   3                {
 117   4                    Lora_Uart_State = 1;
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 3   

 118   4                }
 119   3                else
 120   3                {
 121   4                  P30 = 1;
 122   4                }
 123   3      
 124   3               }
 125   2      
 126   2        }   
 127   1      }
 128          void Hand_PAYG()
 129          {
 130   1        unsigned char i = 0;
 131   1        for(i = 0; i < 16; i++)
 132   1        UartSend(0x00);
 133   1        UartSend(0xc5);
 134   1        UartSend(0x6a);
 135   1        UartSend(0x29);
 136   1        UartSend(0x07);
 137   1        UartSend(0x04);
 138   1        UartSend(0x01);
 139   1        UartSend(0x24);
 140   1      }
 141          void Lora_Buffer_Analysis()
 142          {
 143   1        unsigned char i = 0,j = 0,k = 0,tx_num = 0;
 144   1        unsigned char *dest,*src;
 145   1        if(buffer2[14] == 0x0E && buffer2[15] == 0xFA)//这是充值命令
 146   1        {
 147   2          MCU_Uart_State = 0;
 148   2          REN = 0;//关闭串口接收中断
 149   2          for(i = 0; i < 16; i++)
 150   2          {
 151   3            UartSend(0x00);
 152   3          }
 153   2          UartSend(buffer2[11]);
 154   2          UartSend(buffer2[12]);
 155   2          UartSend(buffer2[13]);
 156   2          UartSend(buffer2[14]);
 157   2          UartSend(buffer2[15]);
 158   2          UartSend(buffer2[16]);
 159   2          UartSend(buffer2[17]);
 160   2          UartSend(buffer2[18]);
 161   2          UartSend(buffer2[19]);
 162   2          UartSend(buffer2[20]);
 163   2          UartSend(buffer2[21]);
 164   2          UartSend(buffer2[22]);
 165   2          UartSend(buffer2[23]);
 166   2          UartSend(buffer2[24]);
 167   2          REN = 1;//打开串口接收中断
 168   2          SYS_STATE = 2;
 169   2          SYS_TIMER_START;
 170   2          do
 171   2          {
 172   3            //      P30 = ~P30;
 173   3            if(MCU_Uart_State ==1)//有充值回复
 174   3            {       
 175   4                      MCU_Uart_State = 0;
 176   4                    dest = TX_buf2;
 177   4                    *dest++ = 0xaf;
 178   4                    *dest++ = 0x00;
 179   4                    *dest++ = 0x00;
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 4   

 180   4                    *dest++ = 0x00;
 181   4                    *dest++ = 0x00;
 182   4                    *dest++ = 0x00;
 183   4                    *dest++ = 0x00;
 184   4                    *dest++ = 0x02;
 185   4                    *dest++ = 0x14;
 186   4                    *dest++ = 0x11;
 187   4                    *dest++ = buffer[3];          
 188   4                    for(i = 0; i < buffer[3] ; i++)
 189   4                    {
 190   5                      *dest++ = buffer[i];
 191   5                    }
 192   4                    *dest++ = GetCheckSum_Xor(TX_buf2, buffer[3] +10);
 193   4                    *dest++ = 0x3C;
 194   4                    for( i = 0; i < buffer[3]+ 13 ; i++)
 195   4                    {
 196   5                      Uart2Send(TX_buf2[i]);
 197   5                    }
 198   4      
 199   4      //          if(buffer[4] == 0xfa && buffer[5] == 0x0a)
 200   4      //          {
 201   4      //              //充值成功
 202   4      //              dest = TX_buf2;
 203   4      //              *dest++ = 0xaf;
 204   4      //              *dest++ = 0x00;
 205   4      //              *dest++ = 0x00;
 206   4      //              *dest++ = 0x00;
 207   4      //              *dest++ = 0x00;
 208   4      //              *dest++ = 0x00;
 209   4      //              *dest++ = 0x00;
 210   4      //              *dest++ = 0x02;
 211   4      //              *dest++ = 0x12;
 212   4      //              *dest++ = 0x11;
 213   4      //              *dest++ = buffer[3];          
 214   4      //              for(i = 0; i < buffer[3] ; i++)
 215   4      //              {
 216   4      //                *dest++ = buffer[i];
 217   4      //              }
 218   4      //              *dest++ = GetCheckSum_Xor(TX_buf2, tx_num +10);
 219   4      //              *dest++ = 0x3C;
 220   4      //              for( i = 0; i < tx_num + 13 ; i++)
 221   4      //              {
 222   4      //                Uart2Send(TX_buf2[i]);
 223   4      //              }
 224   4      //          }
 225   4      //          else if(buffer[4] == 0xfa && buffer[5] == 0xa0)
 226   4      //          {
 227   4      //              //充值失败
 228   4      //                          dest = TX_buf2;
 229   4      //              *dest++ = 0xaf;
 230   4      //              *dest++ = 0x00;
 231   4      //              *dest++ = 0x00;
 232   4      //              *dest++ = 0x00;
 233   4      //              *dest++ = 0x00;
 234   4      //              *dest++ = 0x00;
 235   4      //              *dest++ = 0x00;
 236   4      //              *dest++ = 0x02;
 237   4      //              *dest++ = 0x12;
 238   4      //              *dest++ = 0x11;
 239   4      //              *dest++ = buffer[3];          
 240   4      //              for(i = 0; i < buffer[3] ; i++)
 241   4      //              {
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 5   

 242   4      //                *dest++ = buffer[i];
 243   4      //              }
 244   4      //              *dest++ = GetCheckSum_Xor(TX_buf2, tx_num +10);
 245   4      //              *dest++ = 0x3C;
 246   4      //              for( i = 0; i < tx_num + 13 ; i++)
 247   4      //              {
 248   4      //                Uart2Send(TX_buf2[i]);
 249   4      //              }
 250   4      //          }
 251   4      //          else if(buffer[4] == 0xff && buffer[5] == 0xee)
 252   4      //          {
 253   4      //              //充值密码已使用
 254   4      //            P31 = 0 ;
 255   4      //              dest = TX_buf2;
 256   4      //              *dest++ = 0xaf;
 257   4      //              *dest++ = 0x00;
 258   4      //              *dest++ = 0x00;
 259   4      //              *dest++ = 0x00;
 260   4      //              *dest++ = 0x00;
 261   4      //              *dest++ = 0x00;
 262   4      //              *dest++ = 0x00;
 263   4      //              *dest++ = 0x02;
 264   4      //              *dest++ = 0x12;
 265   4      //              *dest++ = 0x11;
 266   4      //              *dest++ = buffer[3];          
 267   4      //              for(i = 0; i < buffer[3] ; i++)
 268   4      //              {
 269   4      //                *dest++ = buffer[i];
 270   4      //              }
 271   4      //              *dest++ = GetCheckSum_Xor(TX_buf2, tx_num +10);
 272   4      //              *dest++ = 0x3C;
 273   4      //              for( i = 0; i < tx_num + 13 ; i++)
 274   4      //              {
 275   4      //                Uart2Send(TX_buf2[i]);
 276   4      //              }
 277   4      //          }
 278   4                break;
 279   4            }
 280   3            Delay1S();
 281   3            k++;
 282   3      
 283   3          }while( k < RECHARGETIME);
 284   2        }
 285   1        else
 286   1        {
 287   2            tx_num  = 0;
 288   2            dest = TX_buf;
 289   2            info_num = 0;
 290   2            for(; j < 23; j++)command[j] = 0x00;//格式化命令缓冲区
 291   2            for(j = 0; j < PaketSize + 7;j++)
 292   2            {
 293   3              if(buffer2[j] == 0x3A && buffer2[j+1] == 0xC5 && buffer2[j+2] == 0x6A && buffer2[j+3] == 0x29)
 294   3              {   
 295   4                command[info_num++] = buffer2[j+5];
 296   4                
 297   4                switch(buffer2[j+5])
 298   4                {
 299   5                  case 0x00:
 300   5                  {
 301   6                    if(buffer2[j+6] == 0x08) //查询电池包温度
 302   6                    {
 303   7                        k = 0;
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 6   

 304   7                        MCU_Uart_State = 0;//串口没有数据
 305   7                      do{
 306   8                          for(i = 0; i < 16; i++)
 307   8                          UartSend(0x00);
 308   8                          
 309   8                          UartSend(0xc5);
 310   8                          UartSend(0x6a);
 311   8                          UartSend(0x29);
 312   8                          UartSend(0x08);
 313   8                          UartSend(0x00);
 314   8                          UartSend(0x08);
 315   8                          UartSend(0x02);
 316   8                          UartSend(0x48);                 
 317   8                          k++;
 318   8                         Delay20ms();
 319   8                        if(MCU_Uart_State == 1)
 320   8                        {
 321   9                          src = buffer;
 322   9                          *dest++ = 0x3A;tx_num ++;
 323   9                          for( i = 0; i < buffer[3]; i++)
 324   9                          {
 325  10                            *dest++ = *src++;
 326  10                             tx_num ++;
 327  10                          }
 328   9                          Delay20ms();
 329   9                          break;
 330   9                        }
 331   8                        Delay20ms();
 332   8                        }while( k < NO_ASK_NUM );
 333   7                    }
 334   6                    else if(buffer2[j+6] == 0x09)//读取电池包电压
 335   6                    {
 336   7                        k = 0;
 337   7                        MCU_Uart_State = 0;//串口没有数据
 338   7                      do{
 339   8                          for(i = 0; i < 16; i++)
 340   8                          UartSend(0x00);
 341   8                          
 342   8                          UartSend(0xc5);
 343   8                          UartSend(0x6a);
 344   8                          UartSend(0x29);
 345   8                          UartSend(0x08);
 346   8                          UartSend(0x00);
 347   8                          UartSend(0x09);
 348   8                          UartSend(0x02);
 349   8                          UartSend(0x8c);                 
 350   8                          k++;
 351   8                         Delay20ms();
 352   8                        if(MCU_Uart_State == 1)
 353   8                        {
 354   9                          src = buffer;
 355   9                          *dest++ = 0x3A;tx_num ++;
 356   9                          for( i = 0; i < buffer[3]; i++)
 357   9                          {
 358  10                            *dest++ = *src++;
 359  10                             tx_num ++;
 360  10                          }
 361   9                          Delay20ms();
 362   9                          break;
 363   9                        }
 364   8                        Delay20ms();
 365   8                        }while( k < NO_ASK_NUM );
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 7   

 366   7                    }
 367   6                    else if(buffer2[j+6] == 0x0a)
 368   6                    {
 369   7                        k = 0;
 370   7                        MCU_Uart_State = 0;//串口没有数据
 371   7                      do{
 372   8                          for(i = 0; i < 16; i++)
 373   8                          UartSend(0x00);
 374   8                          
 375   8                          UartSend(0xc5);
 376   8                          UartSend(0x6a);
 377   8                          UartSend(0x29);
 378   8                          UartSend(0x08);
 379   8                          UartSend(0x00);
 380   8                          UartSend(0x0a);
 381   8                          UartSend(0x02);
 382   8                          UartSend(0xd9);                 
 383   8                          k++;
 384   8                         Delay20ms();
 385   8                        if(MCU_Uart_State == 1)
 386   8                        {
 387   9                          src = buffer;
 388   9                          *dest++ = 0x3A;tx_num ++;
 389   9                          for( i = 0; i < buffer[3]; i++)
 390   9                          {
 391  10                            *dest++ = *src++;
 392  10                             tx_num ++;
 393  10                          }
 394   9                          Delay20ms();
 395   9                          break;
 396   9                        }
 397   8                        Delay20ms();
 398   8                        }while( k < NO_ASK_NUM );
 399   7                    }
 400   6                    else if(buffer2[j+6] == 0x3c)
 401   6                    {
 402   7                        k = 0;
 403   7                        MCU_Uart_State = 0;//串口没有数据
 404   7                      do{
 405   8                          for(i = 0; i < 16; i++)
 406   8                          UartSend(0x00);
 407   8                          
 408   8                          UartSend(0xc5);
 409   8                          UartSend(0x6a);
 410   8                          UartSend(0x29);
 411   8                          UartSend(0x08);
 412   8                          UartSend(0x00);
 413   8                          UartSend(0x3c);
 414   8                          UartSend(0x02);
 415   8                          UartSend(0x5e);                 
 416   8                          k++;
 417   8                         Delay20ms();
 418   8                        if(MCU_Uart_State == 1)
 419   8                        {
 420   9                          src = buffer;
 421   9                          *dest++ = 0x3A;tx_num ++;
 422   9                          for( i = 0; i < buffer[3]; i++)
 423   9                          {
 424  10                            *dest++ = *src++;
 425  10                             tx_num ++;
 426  10                          }
 427   9                          Delay20ms();
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 8   

 428   9                          break;
 429   9                        }
 430   8                        Delay20ms();
 431   8                        }while( k < NO_ASK_NUM );
 432   7                    }
 433   6                    else if(buffer2[j+6] == 0x3d)
 434   6                    {
 435   7                        k = 0;
 436   7                        MCU_Uart_State = 0;//串口没有数据
 437   7                      do{
 438   8                          for(i = 0; i < 16; i++)
 439   8                          UartSend(0x00);
 440   8                          
 441   8                          UartSend(0xc5);
 442   8                          UartSend(0x6a);
 443   8                          UartSend(0x29);
 444   8                          UartSend(0x08);
 445   8                          UartSend(0x00);
 446   8                          UartSend(0x3d);
 447   8                          UartSend(0x02);
 448   8                          UartSend(0x9a);                 
 449   8                          k++;
 450   8                         Delay20ms();
 451   8                        if(MCU_Uart_State == 1)
 452   8                        {
 453   9                          src = buffer;
 454   9                          *dest++ = 0x3A;tx_num ++;
 455   9                          for( i = 0; i < buffer[3]; i++)
 456   9                          {
 457  10                            *dest++ = *src++;
 458  10                             tx_num ++;
 459  10                          }
 460   9                          Delay20ms();
 461   9                          break;
 462   9                        }
 463   8                        Delay20ms();
 464   8                        }while( k < NO_ASK_NUM );
 465   7                    }
 466   6                    else if(buffer2[j+6] == 0x3e)
 467   6                    {
 468   7                        k = 0;
 469   7                        MCU_Uart_State = 0;//串口没有数据
 470   7                      do{
 471   8                          for(i = 0; i < 16; i++)
 472   8                          UartSend(0x00);
 473   8                          
 474   8                          UartSend(0xc5);
 475   8                          UartSend(0x6a);
 476   8                          UartSend(0x29);
 477   8                          UartSend(0x08);
 478   8                          UartSend(0x00);
 479   8                          UartSend(0x3e);
 480   8                          UartSend(0x02);
 481   8                          UartSend(0xcf);                 
 482   8                          k++;
 483   8                         Delay20ms();
 484   8                        if(MCU_Uart_State == 1)
 485   8                        {
 486   9                          src = buffer;
 487   9                          *dest++ = 0x3A;tx_num ++;
 488   9                          for( i = 0; i < buffer[3]; i++)
 489   9                          {
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 9   

 490  10                            *dest++ = *src++;
 491  10                             tx_num ++;
 492  10                          }
 493   9                          Delay20ms();
 494   9                          break;
 495   9                        }
 496   8                        Delay20ms();
 497   8                        }while( k < NO_ASK_NUM );
 498   7                    }
 499   6                    else if(buffer2[j+6] == 0x3f)
 500   6                    {
 501   7                        k = 0;
 502   7                        MCU_Uart_State = 0;//串口没有数据
 503   7                      do{
 504   8                          for(i = 0; i < 16; i++)
 505   8                          UartSend(0x00);
 506   8                          
 507   8                          UartSend(0xc5);
 508   8                          UartSend(0x6a);
 509   8                          UartSend(0x29);
 510   8                          UartSend(0x08);
 511   8                          UartSend(0x00);
 512   8                          UartSend(0x3f);
 513   8                          UartSend(0x02);
 514   8                          UartSend(0x0b);                 
 515   8                          k++;
 516   8                         Delay20ms();
 517   8                        if(MCU_Uart_State == 1)
 518   8                        {
 519   9                          src = buffer;
 520   9                          *dest++ = 0x3A;tx_num ++;
 521   9                          for( i = 0; i < buffer[3]; i++)
 522   9                          {
 523  10                            *dest++ = *src++;
 524  10                             tx_num ++;
 525  10                          }
 526   9                          Delay20ms();
 527   9                          break;
 528   9                        }
 529   8                        Delay20ms();
 530   8                        }while( k < NO_ASK_NUM );
 531   7                    }
 532   6                  }break;
 533   5                  case 0x01:
 534   5                  {
 535   6                    k = 0;
 536   6                    MCU_Uart_State = 0;//串口没有数据
 537   6                  do{
 538   7                      for(i = 0; i < 16; i++)
 539   7                      UartSend(0x00);
 540   7                      
 541   7                      UartSend(0xc5);
 542   7                      UartSend(0x6a);
 543   7                      UartSend(0x29);
 544   7                      UartSend(0x07);
 545   7                      UartSend(0x01);
 546   7                      UartSend(0x0E);
 547   7                      UartSend(0x9A);
 548   7                      k++;
 549   7                     Delay20ms();
 550   7                    if(MCU_Uart_State == 1)
 551   7                    {
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 10  

 552   8                      src = buffer;
 553   8                      *dest++ = 0x3A;tx_num ++;
 554   8                      for( i = 0; i < buffer[3]; i++)
 555   8                      {
 556   9                        *dest++ = *src++;
 557   9                         tx_num ++;
 558   9                      }
 559   8                      Delay20ms();
 560   8                      break;
 561   8                    }
 562   7                    Delay20ms();
 563   7                    }while( k < NO_ASK_NUM );
 564   6                  }break;
 565   5                  case 0x05:
 566   5                  { 
 567   6                    k = 0;
 568   6                    MCU_Uart_State = 0;
 569   6                    do{
 570   7                    for(i = 0; i < 16; i++)
 571   7                    UartSend(0x00);
 572   7                    
 573   7                    UartSend(0xc5);
 574   7                    UartSend(0x6a);
 575   7                    UartSend(0x29);
 576   7                    UartSend(0x06);
 577   7                    UartSend(0x05);
 578   7                    UartSend(0xf4);
 579   7                    Delay20ms();
 580   7                    Delay20ms();
 581   7                    if(MCU_Uart_State == 1)
 582   7                    {
 583   8                      
 584   8                      src = buffer;
 585   8                      *dest++ = 0x3A;tx_num ++;
 586   8                      for( i = 0; i < buffer[3]; i++)
 587   8                      {
 588   9                        *dest++ = *src++;
 589   9                         tx_num ++;
 590   9                      }
 591   8                      Delay20ms();
 592   8                      break;
 593   8                    }
 594   7                    Delay20ms();
 595   7                    k++;
 596   7                  }while(k < NO_ASK_NUM);
 597   6                  }break;
 598   5                  case 0x06:
 599   5                  { 
 600   6                    k = 0;
 601   6                    MCU_Uart_State = 0;
 602   6                    do{
 603   7                    for(i = 0; i < 16; i++)
 604   7                    UartSend(0x00);
 605   7                    
 606   7                    UartSend(0xc5);
 607   7                    UartSend(0x6a);
 608   7                    UartSend(0x29);
 609   7                    UartSend(0x06);
 610   7                    UartSend(0x06);
 611   7                    UartSend(0x16);
 612   7                    Delay20ms();
 613   7                    Delay20ms();
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 11  

 614   7                    if(MCU_Uart_State == 1)
 615   7                    {
 616   8                      src = buffer;
 617   8                      *dest++ = 0x3A;tx_num ++;
 618   8                      for( i = 0; i < buffer[3]; i++)
 619   8                      {
 620   9                        *dest++ = *src++;
 621   9                         tx_num ++;
 622   9                      }
 623   8                      Delay20ms();
 624   8                      break;
 625   8                    }
 626   7                    Delay20ms();
 627   7                    k++;
 628   7                  }while(k < NO_ASK_NUM);
 629   6                  }break;           
 630   5                  case 0x07:
 631   5                  {
 632   6                    k = 0;
 633   6                    MCU_Uart_State = 0;
 634   6                    do{
 635   7                    for(i = 0; i < 16; i++)
 636   7                    UartSend(0x00);
 637   7                    
 638   7                    UartSend(0xc5);
 639   7                    UartSend(0x6a);
 640   7                    UartSend(0x29);
 641   7                    UartSend(0x06);
 642   7                    UartSend(0x07);
 643   7                    UartSend(0x48);
 644   7                    Delay20ms();
 645   7                    if(MCU_Uart_State == 1)
 646   7                    {
 647   8                        src = buffer;
 648   8                        *dest++ = 0x3A;tx_num ++;
 649   8                        for( i = 0; i < buffer[3]; i++)
 650   8                        {
 651   9                          *dest++ = *src++;
 652   9                           tx_num ++;
 653   9                        }
 654   8                      Delay20ms();
 655   8                      break;
 656   8                    }
 657   7                    Delay20ms();
 658   7                    k++;
 659   7                  }while(k < NO_ASK_NUM);
 660   6                  }break;
 661   5                  case 0x08:
 662   5                  {
 663   6                    k = 0;
 664   6                    MCU_Uart_State = 0;
 665   6                    do{
 666   7                    for(i = 0; i < 16; i++)
 667   7                    UartSend(0x00);
 668   7                    
 669   7                    UartSend(0xc5);
 670   7                    UartSend(0x6a);
 671   7                    UartSend(0x29);
 672   7                    UartSend(0x07);
 673   7                    UartSend(0x08);
 674   7                    UartSend(0x14);
 675   7                    UartSend(0xcb);
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 12  

 676   7                    Delay20ms();
 677   7                    if(MCU_Uart_State == 1)
 678   7                    {
 679   8                        src = buffer;
 680   8                        *dest++ = 0x3A;tx_num ++;
 681   8                        for( i = 0; i < buffer[3]; i++)
 682   8                        {
 683   9                          *dest++ = *src++;
 684   9                           tx_num ++;
 685   9                        }
 686   8                      break;
 687   8                    }
 688   7                    k++;
 689   7                  }while(k < NO_ASK_NUM);
 690   6                  }break;
 691   5                  case 0x09:
 692   5                  {
 693   6                    k = 0;
 694   6                    MCU_Uart_State = 0;
 695   6                    do{
 696   7                    for(i = 0; i < 16; i++)
 697   7                    UartSend(0x00);
 698   7                    
 699   7                    UartSend(0xc5);
 700   7                    UartSend(0x6a);
 701   7                    UartSend(0x29);
 702   7                    UartSend(0x06);
 703   7                    UartSend(0x09);
 704   7                    UartSend(0x57);
 705   7                    Delay20ms();
 706   7                    if(MCU_Uart_State == 1)
 707   7                    {
 708   8                        src = buffer;
 709   8                        *dest++ = 0x3A;tx_num ++;
 710   8                        for( i = 0; i < buffer[3]; i++)
 711   8                        {
 712   9                          *dest++ = *src++;
 713   9                           tx_num ++;
 714   9                        }
 715   8                      break;
 716   8                    }
 717   7                    k++;
 718   7                  }while(k < NO_ASK_NUM);
 719   6                  }break;
 720   5                  case 0x0a:
 721   5                  {
 722   6                    k = 0;
 723   6                    MCU_Uart_State = 0;
 724   6                    do{
 725   7                    for(i = 0; i < 16; i++)
 726   7                    UartSend(0x00);
 727   7                    
 728   7                    UartSend(0xc5);
 729   7                    UartSend(0x6a);
 730   7                    UartSend(0x29);
 731   7                    UartSend(0x06);
 732   7                    UartSend(0x0a);
 733   7                    UartSend(0xb5);
 734   7                    Delay20ms();
 735   7                    if(MCU_Uart_State == 1)
 736   7                    {
 737   8                      if(buffer[3] == 0x08 && buffer[4] == 0x0a)
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 13  

 738   8                      {           
 739   9                        src = buffer;
 740   9                        *dest++ = 0x3A;tx_num ++;
 741   9                        for( i = 0; i < buffer[3]; i++)
 742   9                        {
 743  10                          *dest++ = *src++;
 744  10                           tx_num ++;
 745  10                        }
 746   9      
 747   9                      }
 748   8                      break;
 749   8                    }
 750   7                    k++;
 751   7                  }while(k < NO_ASK_NUM);
 752   6                  }break;
 753   5                  case 0x0b:
 754   5                  {
 755   6                    k = 0;
 756   6                    MCU_Uart_State = 0;
 757   6                    do{
 758   7                    for(i = 0; i < 16; i++)
 759   7                    UartSend(0x00);
 760   7                    
 761   7                    UartSend(0xc5);
 762   7                    UartSend(0x6a);
 763   7                    UartSend(0x29);
 764   7                    UartSend(0x06);
 765   7                    UartSend(0x0b);
 766   7                    UartSend(0xeb);
 767   7                    Delay20ms();
 768   7                    if(MCU_Uart_State == 1)
 769   7                    {
 770   8                      if(buffer[3] == 0x08 && buffer[4] == 0x0b)
 771   8                      {
 772   9                        src = buffer;
 773   9                        *dest++ = 0x3A;tx_num ++;
 774   9                        for( i = 0; i < buffer[3]; i++)
 775   9                        {
 776  10                          *dest++ = *src++;
 777  10                           tx_num ++;
 778  10                        }
 779   9                      }
 780   8                      break;
 781   8                    }
 782   7                    k++;
 783   7                  }while(k < NO_ASK_NUM);
 784   6                  }break;
 785   5                  case 0x0c: //剩余容量
 786   5                  {
 787   6                    k = 0;
 788   6                    MCU_Uart_State = 0;
 789   6                    do{
 790   7                    for(i = 0; i < 16; i++)
 791   7                    UartSend(0x00);
 792   7                    
 793   7                    UartSend(0xc5);
 794   7                    UartSend(0x6a);
 795   7                    UartSend(0x29);
 796   7                    UartSend(0x06);
 797   7                    UartSend(0x0c);
 798   7                    UartSend(0x68);
 799   7                    Delay20ms();
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 14  

 800   7                    if(MCU_Uart_State == 1)
 801   7                    {
 802   8                      if(buffer[3] == 0x08 && buffer[4] == 0x0c)
 803   8                      {
 804   9                        src = buffer;
 805   9                        *dest++ = 0x3A;tx_num ++;
 806   9                        for( i = 0; i < buffer[3]; i++)
 807   9                        {
 808  10                          *dest++ = *src++;
 809  10                           tx_num ++;
 810  10                        }
 811   9                      }
 812   8                      break;
 813   8                    }
 814   7                    k++;
 815   7                  }while(k < NO_ASK_NUM);
 816   6                  }break;
 817   5                  case 0x0d:
 818   5                  {
 819   6                    k = 0;
 820   6                    MCU_Uart_State = 0;
 821   6                    do{
 822   7                    for(i = 0; i < 16; i++)
 823   7                    UartSend(0x00);
 824   7                    
 825   7                    UartSend(0xc5);
 826   7                    UartSend(0x6a);
 827   7                    UartSend(0x29);
 828   7                    UartSend(0x06);
 829   7                    UartSend(0x0d);
 830   7                    UartSend(0x36);
 831   7                    Delay20ms();
 832   7                      Delay20ms();
 833   7                    if(MCU_Uart_State == 1)
 834   7                    {
 835   8                      if(buffer[3] == 0x08 && buffer[4] == 0x0d)
 836   8                      {
 837   9                        src = buffer;
 838   9                        *dest++ = 0x3A;tx_num ++;
 839   9                        for( i = 0; i < buffer[3]; i++)
 840   9                        {
 841  10                          *dest++ = *src++;
 842  10                           tx_num ++;
 843  10                        }
 844   9                      }
 845   8                      break;
 846   8                    }
 847   7                  k++;
 848   7                  }while(k < NO_ASK_NUM);
 849   6                  }break;
 850   5                  case 0x0e: //读取设备满足容量 FCC
 851   5                  {
 852   6                    k = 0;
 853   6                    MCU_Uart_State = 0;
 854   6                    do{
 855   7                    for(i = 0; i < 16; i++)
 856   7                    UartSend(0x00);
 857   7                    
 858   7                    UartSend(0xc5);
 859   7                    UartSend(0x6a);
 860   7                    UartSend(0x29);
 861   7                    UartSend(0x06);
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 15  

 862   7                    UartSend(0x0e);
 863   7                    UartSend(0xd4);
 864   7                    Delay20ms();
 865   7                    if(MCU_Uart_State == 1)
 866   7                    {
 867   8                      if(buffer[3] == 0x08 && buffer[4] == 0x0e)
 868   8                      {
 869   9                        src = buffer;
 870   9                        *dest++ = 0x3A;tx_num ++;
 871   9                        for( i = 0; i < buffer[3]; i++)
 872   9                        {
 873  10                          *dest++ = *src++;
 874  10                           tx_num ++;
 875  10                        }
 876   9                      }
 877   8                      break;
 878   8                    }
 879   7                  k++;
 880   7                  }while(k < NO_ASK_NUM);
 881   6                  }break;
 882   5                  case 0x0f://读取设备累计输出电量
 883   5                  {
 884   6                    k = 0;
 885   6                    MCU_Uart_State = 0;
 886   6                    do{
 887   7                    for(i = 0; i < 16; i++)
 888   7                    UartSend(0x00);
 889   7                    
 890   7                    UartSend(0xc5);
 891   7                    UartSend(0x6a);
 892   7                    UartSend(0x29);
 893   7                    UartSend(0x06);
 894   7                    UartSend(0x0f);
 895   7                    UartSend(0x8a);
 896   7                    Delay20ms();
 897   7                    if(MCU_Uart_State == 1)
 898   7                    {
 899   8                      if(buffer[3] == 0x08 && buffer[4] == 0x0f)
 900   8                      {
 901   9                        src = buffer;
 902   9                        *dest++ = 0x3A;tx_num ++;
 903   9                        for( i = 0; i < buffer[3]; i++)
 904   9                        {
 905  10                          *dest++ = *src++;
 906  10                           tx_num ++;
 907  10                        }
 908   9                      }
 909   8                      break;
 910   8                    }
 911   7                  k++;
 912   7                  }while(k < NO_ASK_NUM);
 913   6                  }break;
 914   5                  case 0x10://读取设备循次数
 915   5                  {
 916   6                    k = 0;
 917   6                    MCU_Uart_State = 0;
 918   6                    do{
 919   7                    for(i = 0; i < 16; i++)
 920   7                    UartSend(0x00);
 921   7                    
 922   7                    UartSend(0xc5);
 923   7                    UartSend(0x6a);
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 16  

 924   7                    UartSend(0x29);
 925   7                    UartSend(0x06);
 926   7                    UartSend(0x10);
 927   7                    UartSend(0x56);
 928   7                    Delay20ms();
 929   7                    if(MCU_Uart_State == 1)
 930   7                    {
 931   8                      if(buffer[3] == 0x08 && buffer[4] == 0x10)
 932   8                      {
 933   9                        src = buffer;
 934   9                        *dest++ = 0x3A;tx_num ++;
 935   9                        for( i = 0; i < buffer[3]; i++)
 936   9                        {
 937  10                          *dest++ = *src++;
 938  10                           tx_num ++;
 939  10                        }
 940   9                      }
 941   8                      break;
 942   8                    }
 943   7                  k++;
 944   7                  }while(k < NO_ASK_NUM);
 945   6                  }break;
 946   5                  case 0x11://读HUSHTOP参数
 947   5                  {
 948   6                    k = 0;
 949   6                    MCU_Uart_State = 0;
 950   6                    do{
 951   7                    for(i = 0; i < 16; i++)
 952   7                    UartSend(0x00);
 953   7                    
 954   7                    UartSend(0xc5);
 955   7                    UartSend(0x6a);
 956   7                    UartSend(0x29);
 957   7                    UartSend(0x06);
 958   7                    UartSend(0x11);
 959   7                    UartSend(0x08);
 960   7                    Delay20ms();
 961   7                    if(MCU_Uart_State == 1)
 962   7                    {
 963   8                      if(buffer[3] == 0x0e && buffer[4] == 0x11)
 964   8                      {
 965   9                        src = buffer;
 966   9                        *dest++ = 0x3A;tx_num ++;
 967   9                        for( i = 0; i < buffer[3]; i++)
 968   9                        {
 969  10                          *dest++ = *src++;
 970  10                           tx_num ++;
 971  10                        }
 972   9                      }
 973   8                      break;
 974   8                    }
 975   7                  k++;
 976   7                  }while(k < NO_ASK_NUM);
 977   6                  }break;   
 978   5                  case 0x13://读取设备已运行天数 RDB  
 979   5                  {
 980   6                    k = 0;
 981   6                    MCU_Uart_State = 0;
 982   6                    do{
 983   7                    for(i = 0; i < 16; i++)
 984   7                    UartSend(0x00);
 985   7                    
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 17  

 986   7                    UartSend(0xc5);
 987   7                    UartSend(0x6a);
 988   7                    UartSend(0x29);
 989   7                    UartSend(0x06);
 990   7                    UartSend(0x13);
 991   7                    UartSend(0xb4);
 992   7                    Delay20ms();
 993   7                    if(MCU_Uart_State == 1)
 994   7                    {
 995   8                      if(buffer[3] == 0x08 && buffer[4] == 0x13)
 996   8                      {
 997   9                        src = buffer;
 998   9                        *dest++ = 0x3A;tx_num ++;
 999   9                        for( i = 0; i < buffer[3]; i++)
1000   9                        {
1001  10                          *dest++ = *src++;
1002  10                           tx_num ++;
1003  10                        }
1004   9                      }
1005   8                      break;
1006   8                    }
1007   7                  k++;
1008   7                  }while(k < NO_ASK_NUM);
1009   6                  }break;
1010   5                  case 0x14://读软件版本
1011   5                  {
1012   6                    k = 0;
1013   6                    MCU_Uart_State = 0;
1014   6                    do{
1015   7                    for(i = 0; i < 16; i++)
1016   7                    UartSend(0x00);
1017   7                    
1018   7                    UartSend(0xc5);
1019   7                    UartSend(0x6a);
1020   7                    UartSend(0x29);
1021   7                    UartSend(0x06);
1022   7                    UartSend(0x14);
1023   7                    UartSend(0x37);
1024   7                    Delay20ms();
1025   7                    if(MCU_Uart_State == 1)
1026   7                    {
1027   8                      if(buffer[3] == 0x08 && buffer[4] == 0x14)
1028   8                      {
1029   9                        src = buffer;
1030   9                        *dest++ = 0x3A;tx_num ++;
1031   9                        for( i = 0; i < buffer[3]; i++)
1032   9                        {
1033  10                          *dest++ = *src++;
1034  10                           tx_num ++;
1035  10                        }
1036   9                      }
1037   8                      break;
1038   8                    }
1039   7                  k++;
1040   7                  }while(k < NO_ASK_NUM);
1041   6                  }break;             
1042   5                    default :break;
1043   5                }
1044   4              }
1045   3      
1046   3            }
1047   2            dest = TX_buf2;
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 18  

1048   2            *dest++ = 0xaf;
1049   2            *dest++ = 0x00;
1050   2            *dest++ = 0x00;
1051   2            *dest++ = 0x00;
1052   2            *dest++ = 0x00;
1053   2            *dest++ = 0x00;
1054   2            *dest++ = 0x00;
1055   2            *dest++ = 0x02;
1056   2            *dest++ = 0x14;
1057   2            *dest++ = 0x11;
1058   2            *dest++ = tx_num;     
1059   2            for(i = 0; i < tx_num ; i++)
1060   2            {
1061   3              *dest++ = TX_buf[i];
1062   3            }
1063   2            *dest++ = GetCheckSum_Xor(TX_buf2, tx_num +10);
1064   2            *dest++ = 0x3C;
1065   2            for( i = 0; i < tx_num + 13 ; i++)
1066   2            {
1067   3              Uart2Send(TX_buf2[i]);
1068   3            }
1069   2            
1070   2      //    UartSendStr("这是一帧数据接收包 \r\n");
1071   2        }
1072   1      }
1073          /********************************************************************************
1074          ** Name:    CRC8 ??
1075          ** Function: 
1076          ** Input:   
1077          ** Output:   
1078          ********************************************************************************/
1079          
1080              
1081          unsigned char CRC8(unsigned char *p, char counter)
1082           {
1083   1          unsigned char crc8 = 0;
1084   1      
1085   1          for( ; counter > 0; counter--)
1086   1      
1087   1          {
1088   2                crc8 = crc_array[crc8^*p]; //????CRC?
1089   2                 p++;
1090   2          }
1091   1           return crc8;
1092   1      
1093   1       }
1094           
1095          unsigned char GetCheckSum_Xor(unsigned char *p,unsigned char len)
1096          {
1097   1        unsigned char i,Cs,temp;
1098   1        Cs = p[1];
1099   1        for(i=1;i<len;i++)
1100   1        {
1101   2          temp = Cs;
1102   2          Cs = temp^p[i + 1];
1103   2        }
1104   1        
1105   1        return Cs;
1106   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.52.0.0   LORA_PROTOCOL                                                     01/12/2018 09:44:49 PAGE 19  

   CODE SIZE        =   5772    ----
   CONSTANT SIZE    =    256    ----
   XDATA SIZE       =    279    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
